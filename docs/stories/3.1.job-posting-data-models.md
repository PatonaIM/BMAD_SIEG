# Story 3.1: Job Posting Data Models and Database Schema - Brownfield Addition

## Status
Ready for Review

## Story Context

**Existing System Integration:**
- Integrates with: Existing database schema (candidates, interviews tables)
- Technology: SQLAlchemy 2.x ORM, PostgreSQL 15+, Alembic migrations
- Follows pattern: Existing model patterns (candidate.py, interview.py)
- Touch points: Foreign keys to candidates.id and interviews.id tables

## User Story

**As a** developer,  
**I want** database tables for job postings and applications with proper relationships to candidates and interviews,  
**so that** the system can store and retrieve job data for the candidate application flow.

## Acceptance Criteria

**Functional Requirements:**

1. `job_postings` table created with fields: id (UUID), title, company, description, role_category (enum: engineering|quality_assurance|data|devops|design|product|sales|support|operations|management|other), tech_stack (VARCHAR, nullable), employment_type (enum: permanent|contract|part_time), work_setup (enum: remote|hybrid|onsite), location, salary_min (NUMERIC), salary_max (NUMERIC), salary_currency (default 'AUD'), required_skills (JSONB), experience_level, status (default 'active'), is_cancelled (BOOLEAN), cancellation_reason (TEXT), created_at, updated_at
2. `applications` table created with fields: id (UUID), candidate_id (FK), job_posting_id (FK), status (enum: applied|interview_scheduled|interview_completed|under_review|rejected|offered|accepted|withdrawn), applied_at, interview_id (FK, nullable), created_at, updated_at
3. SQLAlchemy models created: `JobPosting` and `Application` following existing coding standards
4. Alembic migration created with proper up/down functions
5. Foreign key indexes created on candidate_id, job_posting_id, interview_id
6. Unique constraint on (candidate_id, job_posting_id) to prevent duplicate applications

**Integration Requirements:**

7. Existing candidates, interviews, and all other tables continue to work unchanged
8. New models follow existing SQLAlchemy pattern (UUID primary keys, timestamps, relationships, __repr__)
9. Integration with existing database maintains current behavior (all existing tests pass if any)

**Quality Requirements:**

10. Migration tested: can apply to fresh database and existing database, can rollback cleanly
11. Code follows existing patterns and standards (imports, docstrings, type hints)
12. Models properly imported in `app/models/__init__.py`

## Technical Notes

**Integration Approach:**
- New tables are independent additions with foreign keys to existing schema
- No modifications to existing tables (candidates, interviews, etc.)
- Migration uses standard Alembic patterns from existing migrations
- Models use same SQLAlchemy Base and patterns as candidate.py, interview.py

**Existing Pattern Reference:**
- See `backend/app/models/candidate.py` for model structure
- See `backend/app/models/interview.py` for enum usage and JSONB columns
- See `backend/alembic/versions/075e167c8434_initial_schema_with_core_tables.py` for migration patterns

**Key Constraints:**
- role_category enum defines job function (engineering, support, sales, etc.)
- tech_stack is flexible VARCHAR(100) field (nullable for non-technical roles)
- tech_stack examples: 'React', 'Python', 'TypeScript', 'Playwright', 'Java', '.NET', 'Go', etc.
- tech_stack can be used to drive AI interview customization when matching values exist
- UUID primary keys with uuid.uuid4 default (consistent with existing models)
- Timestamps use datetime.utcnow (consistent with existing models)
- Foreign key CASCADE/SET NULL must preserve data integrity
- salary_currency defaults to 'AUD' for Australian market
- work_setup uses 'onsite' instead of 'office' for clarity

## Definition of Done

- [ ] `JobPosting` model created in `backend/app/models/job_posting.py`
- [ ] `Application` model created in `backend/app/models/application.py`
- [ ] Models imported in `backend/app/models/__init__.py`
- [ ] Alembic migration created in `backend/alembic/versions/` with descriptive name
- [ ] Migration includes proper upgrade() and downgrade() functions
- [ ] Migration tested on fresh database: `alembic upgrade head` succeeds
- [ ] Migration tested on existing database (with candidate/interview data)
- [ ] Migration rollback tested: `alembic downgrade -1` succeeds
- [ ] Database indexes verified (check with `\d applications` and `\d job_postings` in psql)
- [ ] No changes made to existing tables or models
- [ ] Code follows existing patterns (docstrings, type hints, __repr__)

## Risk and Compatibility Check

**Minimal Risk Assessment:**

- **Primary Risk:** Foreign key constraints may cause issues if interview creation fails after application
- **Mitigation:** Use nullable interview_id with SET NULL on delete, transaction handling in service layer
- **Rollback:** Alembic downgrade script drops tables cleanly, no impact on existing data

**Compatibility Verification:**

- [x] No breaking changes to existing APIs (new tables only, no API changes in this story)
- [x] Database changes are additive only (no existing table modifications)
- [x] UI changes follow existing design patterns (no UI changes in this story)
- [x] Performance impact is negligible (new tables are small, properly indexed)

## Tasks / Subtasks

- [x] **Task 1: Create JobPosting SQLAlchemy model** (AC: 1, 3, 8, 11)
  - [x] Create file `backend/app/models/job_posting.py`
  - [x] Import required modules: uuid, datetime, SQLAlchemy components
  - [x] Define `JobPosting` class inheriting from Base
  - [x] Add table name: `__tablename__ = "job_postings"`
  - [x] Add UUID primary key with uuid4 default
  - [x] Add String columns: title, company, location, experience_level, salary_currency
  - [x] Add Text column: description, cancellation_reason
  - [x] Add role_category enum (engineering|quality_assurance|data|devops|design|product|sales|support|operations|management|other)
  - [x] Add tech_stack VARCHAR(100) column (nullable for non-technical roles)
  - [x] Add employment_type enum (permanent|contract|part_time)
  - [x] Add work_setup enum (remote|hybrid|onsite)
  - [x] Add JSONB column: required_skills
  - [x] Add Numeric columns: salary_min, salary_max (NUMERIC(10, 2))
  - [x] Add Boolean: is_cancelled (default False)
  - [x] Add status column with default 'active' (active|paused|closed)
  - [x] Add timestamps: created_at, updated_at (following existing pattern)
  - [x] Add complete docstring with all field descriptions
  - [x] Add `__repr__` method returning meaningful string
  - [x] Verify imports and type hints are correct

- [x] **Task 2: Create Application SQLAlchemy model** (AC: 2, 3, 5, 6, 8, 11)
  - [x] Create file `backend/app/models/application.py`
  - [x] Import required modules including ForeignKey
  - [x] Define `Application` class inheriting from Base
  - [x] Add table name: `__tablename__ = "applications"`
  - [x] Add UUID primary key with uuid4 default
  - [x] Add foreign key: candidate_id → candidates.id with CASCADE delete
  - [x] Add foreign key: job_posting_id → job_postings.id with CASCADE delete
  - [x] Add foreign key: interview_id → interviews.id (nullable, SET NULL on delete)
  - [x] Add status enum column (applied|interview_scheduled|interview_completed|under_review|rejected|offered|accepted|withdrawn)
  - [x] Add timestamps: applied_at, created_at, updated_at
  - [x] Add relationships: candidate, job_posting, interview (with back_populates)
  - [x] Add unique constraint on (candidate_id, job_posting_id) using `__table_args__`
  - [x] Add complete docstring
  - [x] Add `__repr__` method
  - [x] Verify all foreign key indexes will be created

- [x] **Task 3: Update models __init__.py** (AC: 12)
  - [x] Open `backend/app/models/__init__.py`
  - [x] Import JobPosting: `from app.models.job_posting import JobPosting`
  - [x] Import Application: `from app.models.application import Application`
  - [x] Add to `__all__` list if it exists
  - [x] Verify imports work: `python -c "from app.models import JobPosting, Application"`

- [x] **Task 4: Add relationships to existing models (optional)** (AC: 8, 9)
  - [x] Open `backend/app/models/candidate.py`
  - [x] Add relationship to applications: `applications = relationship("Application", back_populates="candidate", cascade="all, delete-orphan")`
  - [x] Open `backend/app/models/interview.py`
  - [x] Add relationship to applications: `applications = relationship("Application", back_populates="interview")` (no cascade)
  - [x] These are optional for bidirectional navigation but maintain consistency

- [x] **Task 5: Create Alembic migration** (AC: 4, 5, 6, 10)
  - [x] Generate migration: `cd backend && alembic revision -m "add_job_postings_and_applications_tables"`
  - [x] Open generated migration file in `backend/alembic/versions/`
  - [x] In `upgrade()` function:
    - [x] Create `job_postings` table with all columns and proper types (UUID, VARCHAR, TEXT, NUMERIC, JSONB, BOOLEAN, TIMESTAMP, ENUMs)
    - [x] Add indexes: idx_job_postings_role_category, idx_job_postings_tech_stack (partial: WHERE tech_stack IS NOT NULL), idx_job_postings_status (partial: WHERE status = 'active'), idx_job_postings_employment_type, idx_job_postings_created_at
    - [x] Create `applications` table with all columns and foreign keys
    - [x] Add indexes: idx_applications_candidate_id, idx_applications_job_posting_id, idx_applications_interview_id, idx_applications_status, idx_applications_applied_at
    - [x] Add unique constraint: uq_applications_candidate_job on (candidate_id, job_posting_id)
  - [x] In `downgrade()` function:
    - [x] Drop applications table (will automatically drop indexes and constraints)
    - [x] Drop job_postings table
  - [x] Add proper docstring to migration file
  - [x] Verify SQL syntax matches existing migrations

- [x] **Task 6: Test migration on fresh database** (AC: 10)
  - [x] Backup current database (if needed): `pg_dump -U postgres -d teamified_dev > backup.sql`
  - [x] Create test database: `createdb -U postgres teamified_test`
  - [x] Set DATABASE_URL to test database
  - [x] Run migration: `alembic upgrade head`
  - [x] Verify tables created: `psql -U postgres -d teamified_test -c "\d job_postings"`
  - [x] Verify tables created: `psql -U postgres -d teamified_test -c "\d applications"`
  - [x] Check indexes: `psql -U postgres -d teamified_test -c "\di"`
  - [x] Verify foreign keys: `psql -U postgres -d teamified_test -c "\d+ applications"`
  - [x] Drop test database: `dropdb -U postgres teamified_test`

- [x] **Task 7: Test migration on existing database** (AC: 7, 10)
  - [x] Ensure development database has existing candidates and interviews data
  - [x] Run migration on dev database: `alembic upgrade head`
  - [x] Verify existing data intact: query candidates and interviews tables
  - [x] Verify new tables exist and are empty
  - [x] Test foreign key integrity: try inserting application with valid candidate_id
  - [x] Test unique constraint: try inserting duplicate (candidate_id, job_posting_id)

- [x] **Task 8: Test migration rollback** (AC: 10)
  - [x] Run downgrade: `alembic downgrade -1`
  - [x] Verify job_postings and applications tables dropped
  - [x] Verify existing tables still intact
  - [x] Re-run upgrade to restore: `alembic upgrade head`

- [x] **Task 9: Code quality and documentation** (AC: 11)
  - [x] Run Python linter: `ruff check backend/app/models/`
  - [x] Run type checker: `mypy backend/app/models/job_posting.py backend/app/models/application.py`
  - [x] Verify docstrings are complete and accurate
  - [x] Verify code follows existing patterns (compare with candidate.py, interview.py)
  - [x] Add comments for any non-obvious logic

## Integration Verification

**IV1: Existing Schema Integrity** 
- Run migration on copy of existing database
- Verify all existing tables and relationships remain intact
- Query existing data to confirm no data loss occurs
- **Test Command:** `psql -U postgres -d teamified_dev -c "SELECT COUNT(*) FROM candidates;"` (should return same count before/after)

**IV2: Foreign Key Constraints**
- Insert test application with valid candidate_id and job_posting_id
- Delete candidate, verify application is CASCADE deleted
- Insert application, create interview, delete interview, verify application.interview_id set to NULL
- **Test Commands:**
  ```sql
  -- Test CASCADE delete
  INSERT INTO candidates (id, email, full_name, password_hash) VALUES ...;
  INSERT INTO job_postings (id, title, company, role_type) VALUES ...;
  INSERT INTO applications (id, candidate_id, job_posting_id) VALUES ...;
  DELETE FROM candidates WHERE id = ...;
  SELECT * FROM applications WHERE candidate_id = ...; -- Should be empty
  
  -- Test SET NULL
  INSERT INTO interviews (id, candidate_id, role_type) VALUES ...;
  UPDATE applications SET interview_id = ... WHERE id = ...;
  DELETE FROM interviews WHERE id = ...;
  SELECT interview_id FROM applications WHERE id = ...; -- Should be NULL
  ```

**IV3: Tech Stack Flexibility**
- Verify tech_stack accepts any string value (no enum constraint)
- Test inserting job_posting with various tech_stack values
- Verify NULL tech_stack works for non-technical roles
- **Test Commands:**
  ```sql
  -- Test various tech_stack values
  INSERT INTO job_postings (id, title, company, role_category, tech_stack) VALUES 
    (uuid_generate_v4(), 'React Developer', 'Company', 'engineering', 'React');  -- Should succeed
  INSERT INTO job_postings (id, title, company, role_category, tech_stack) VALUES 
    (uuid_generate_v4(), 'TypeScript Engineer', 'Company', 'engineering', 'TypeScript');  -- Should succeed
  INSERT INTO job_postings (id, title, company, role_category, tech_stack) VALUES 
    (uuid_generate_v4(), 'QA Automation', 'Company', 'quality_assurance', 'Playwright');  -- Should succeed
  INSERT INTO job_postings (id, title, company, role_category, tech_stack) VALUES 
    (uuid_generate_v4(), 'Go Backend Developer', 'Company', 'engineering', 'Go');  -- Should succeed
  INSERT INTO job_postings (id, title, company, role_category, tech_stack) VALUES 
    (uuid_generate_v4(), 'Support Rep', 'Company', 'support', NULL);  -- Should succeed (non-technical role)
  
  -- Test role_category enum constraint
  INSERT INTO job_postings (id, title, company, role_category) VALUES 
    (uuid_generate_v4(), 'Test DevOps', 'Company', 'devops');  -- Should succeed
  INSERT INTO job_postings (id, title, company, role_category) VALUES 
    (uuid_generate_v4(), 'Test Invalid Category', 'Company', 'invalid_category');  -- Should fail
  ```

## Notes

- This story focuses solely on database schema; no API or UI changes
- Models provide foundation for Stories 3.2 and 3.3 (repositories/services)
- Migration should be run before starting development on subsequent stories
- role_category defines job function (engineering, support, sales, etc.)
- tech_stack is a flexible string field - examples: 'React', 'Python', 'TypeScript', 'Playwright', 'Go', 'Rust', etc.
- For non-technical roles (sales, support, management), tech_stack can be NULL
- AI interview integration will map tech_stack values to interview types (e.g., 'React'/'TypeScript' → 'react', 'Python' → 'python')
- Consider running migration on staging/test environment first before production

---

**Epic:** Epic 03: Job-Driven AI Interview Flow  
**Dependencies:** None (foundation story)  
**Blocks:** Stories 3.2, 3.3, 3.4, 3.5 (all require these models)

---

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (new)

### Debug Log References
None - Implementation completed without critical issues.

### Completion Notes
- Successfully created JobPosting and Application SQLAlchemy models following existing patterns
- Created Alembic migration c4c387c07d02 with proper enum handling using DO blocks
- All tables, indexes, and foreign key constraints created successfully
- Migration tested: upgrade, downgrade, and re-upgrade all working correctly
- Integration verification tests passed:
  - IV1: Existing schema integrity verified (3 candidates, 88 interviews intact)
  - IV2: Foreign key CASCADE delete and SET NULL constraints working correctly
  - IV3: Tech stack flexibility confirmed with various values and NULL support
- Code quality checks passed (ruff linting clean after fixing trailing whitespace)
- Models properly imported in __init__.py and verified working

### File List
**New Files:**
- `backend/app/models/job_posting.py` - JobPosting model with all required fields and enums
- `backend/app/models/application.py` - Application model with foreign keys and unique constraint
- `backend/alembic/versions/c4c387c07d02_add_job_postings_and_applications_tables.py` - Migration script

**Modified Files:**
- `backend/app/models/__init__.py` - Added JobPosting and Application imports
- `backend/app/models/candidate.py` - Added applications relationship
- `backend/app/models/interview.py` - Added applications relationship

### Change Log
1. Created JobPosting model with role_category enum (11 values), flexible tech_stack VARCHAR, employment_type and work_setup enums, JSONB required_skills, salary fields, and status management
2. Created Application model with unique constraint on (candidate_id, job_posting_id), foreign keys with appropriate CASCADE/SET NULL behavior
3. Generated and implemented Alembic migration using DO blocks for enum creation to handle idempotency
4. Added bidirectional relationships to existing Candidate and Interview models
5. Tested migration on existing Supabase database - all operations successful
6. Verified all integration points: foreign keys, unique constraints, enum validation, tech stack flexibility
