# Story 3.3: Application Repository and Service Layer - Brownfield Addition

## Status
Ready for Review

## Story Context

**Existing System Integration:**
- Depends on: Story 3.1 (Application model created), Story 3.2 (JobPostingRepository created)
- Integrates with: Existing repository/service patterns (CandidateRepository, AuthService)
- Integrates with: InterviewEngine service for automatic interview creation
- Technology: SQLAlchemy 2.x async ORM, FastAPI dependency injection, Transactions
- Follows pattern: BaseRepository abstract class pattern
- Touch points: Interview creation flow, database session management, transaction handling

## Story

**As a** developer,  
**I want** repository and service classes for application operations including interview triggering,  
**so that** candidates can apply to jobs and automatically start customized interviews.

## Acceptance Criteria

**Functional Requirements:**

1. `ApplicationRepository` created with methods: create, get_by_id, get_by_candidate_id, get_by_job_posting_id, update_status, check_existing_application
2. `ApplicationService` created with business logic including duplicate detection and interview triggering
3. `create_application` method checks for existing application and returns appropriate error (409 Conflict)
4. Upon successful application creation, service automatically calls interview engine to create interview
5. Interview created with role_type matching job_posting.role_type
6. Application.interview_id updated after interview creation
7. Application status updated to 'interview_scheduled' after interview link
8. Transaction handling ensures atomicity (rollback if interview creation fails)

**Integration Requirements:**

9. Service integrates with existing InterviewEngine service without modifying core interview logic
10. Service validates job_posting exists and is active before creating application
11. All methods properly typed with type hints following existing standards
12. Service follows existing dependency injection patterns

**Quality Requirements:**

13. Code passes linter checks (ruff)
14. Docstrings follow Google style (existing pattern)
15. Error handling matches existing patterns (HTTPException, proper status codes)

## Tasks / Subtasks

- [ ] **Task 1: Create ApplicationRepository class** (AC: 1, 11, 14)
  - [ ] Create file `backend/app/repositories/application_repository.py`
  - [ ] Import BaseRepository, Application model, necessary SQLAlchemy components
  - [ ] Define `ApplicationRepository(BaseRepository[Application])` class
  - [ ] Implement `__init__(self, db: AsyncSession)` calling super().__init__(db, Application)
  - [ ] Implement `get_by_candidate_id(self, candidate_id: UUID, skip: int = 0, limit: int = 20) -> list[Application]`
    - Use `select(Application).where(Application.candidate_id == candidate_id)`
    - Apply pagination with offset/limit
    - Order by applied_at DESC (newest first)
    - Return `result.scalars().all()`
  - [ ] Implement `get_by_job_posting_id(self, job_posting_id: UUID, skip: int = 0, limit: int = 20) -> list[Application]`
    - Filter WHERE job_posting_id = :job_posting_id
    - Apply pagination
    - Order by applied_at DESC
  - [ ] Implement `check_existing_application(self, candidate_id: UUID, job_posting_id: UUID) -> Application | None`
    - Query WHERE candidate_id AND job_posting_id match
    - Return existing application or None
    - Use `scalar_one_or_none()`
  - [ ] Implement `update_status(self, application_id: UUID, status: str) -> Application`
    - Fetch application by ID
    - Update status field
    - Update updated_at timestamp
    - Flush changes
    - Return updated application
  - [ ] Implement `link_interview(self, application_id: UUID, interview_id: UUID) -> Application`
    - Fetch application by ID
    - Set interview_id field
    - Update status to 'interview_scheduled'
    - Flush changes
    - Return updated application
  - [ ] Add comprehensive docstrings to all methods (Google style)
  - [ ] Verify all type hints are correct

- [ ] **Task 2: Create ApplicationService class** (AC: 2, 3, 4, 5, 6, 7, 8, 10, 12, 15)
  - [ ] Create file `backend/app/services/application_service.py`
  - [ ] Import necessary components: ApplicationRepository, JobPostingRepository, InterviewEngine, HTTPException, structlog
  - [ ] Define `ApplicationService` class
  - [ ] Implement `__init__(self, app_repo: ApplicationRepository, job_repo: JobPostingRepository, interview_engine: InterviewEngine)`
    - Store repository references
    - Store interview engine reference
    - Create logger: `self.logger = structlog.get_logger().bind(service="application_service")`
  - [ ] Implement `create_application(self, candidate_id: UUID, job_posting_id: UUID) -> tuple[Application, InterviewSession]`
    - **Step 1: Validate job posting exists and is active**
      - Call `job_repo.get_by_id(job_posting_id)`
      - Raise HTTPException 404 if not found
      - Raise HTTPException 400 if status != 'active'
    - **Step 2: Check for duplicate application**
      - Call `app_repo.check_existing_application(candidate_id, job_posting_id)`
      - If exists, raise HTTPException 409 Conflict with message "Already applied to this job"
    - **Step 3: Create application record**
      - Create Application instance with candidate_id, job_posting_id, status='applied'
      - Call `app_repo.create(application)`
      - Log application created
    - **Step 4: Create interview automatically** (transaction critical)
      - Extract role_type from job_posting.role_type
      - Call `interview_engine.start_interview(candidate_id, role_type, use_realtime=True)`
      - If interview creation fails, raise exception (transaction will rollback)
      - Log interview created
    - **Step 5: Link interview to application**
      - Call `app_repo.link_interview(application.id, interview.interview_id)`
      - This updates both interview_id and status to 'interview_scheduled'
    - **Step 6: Commit transaction** (handled by FastAPI dependency)
      - Return tuple (application, interview_session)
    - **Error handling:** Wrap in try/except, log errors, re-raise as HTTPException
  - [ ] Implement `get_candidate_applications(self, candidate_id: UUID, skip: int = 0, limit: int = 20) -> list[Application]`
    - Call `app_repo.get_by_candidate_id(candidate_id, skip, limit)`
    - Return applications with eager-loaded relationships (job_posting, interview)
  - [ ] Implement `get_application_by_id(self, application_id: UUID, candidate_id: UUID) -> Application`
    - Call `app_repo.get_by_id(application_id)`
    - Raise HTTPException 404 if not found
    - Verify application.candidate_id == candidate_id (authorization check)
    - Raise HTTPException 403 if unauthorized
    - Return application
  - [ ] Add comprehensive docstrings to all methods
  - [ ] Add structured logging for all operations

- [ ] **Task 3: Transaction handling and rollback testing** (AC: 8, 9)
  - [ ] Verify transaction pattern follows existing FastAPI patterns
  - [ ] Transaction managed by `get_db()` dependency - commit happens after endpoint returns
  - [ ] If interview_engine.start_interview() raises exception, transaction automatically rolls back
  - [ ] ApplicationService should NOT call db.commit() - handled by FastAPI
  - [ ] Test rollback: Mock interview_engine to raise exception, verify application not created
  - [ ] Document transaction behavior in service docstrings

- [ ] **Task 4: Eager loading for relationships** (AC: 1)
  - [ ] Update `get_by_candidate_id` to use `selectinload` or `joinedload`
  - [ ] Eager load: Application -> JobPosting relationship
  - [ ] Eager load: Application -> Interview relationship (nullable)
  - [ ] Import: `from sqlalchemy.orm import selectinload`
  - [ ] Pattern: `select(Application).options(selectinload(Application.job_posting)).where(...)`
  - [ ] Verify relationships loaded without N+1 queries

- [ ] **Task 5: Update repository __init__.py** (AC: 12)
  - [ ] Open `backend/app/repositories/__init__.py`
  - [ ] Import ApplicationRepository: `from app.repositories.application_repository import ApplicationRepository`
  - [ ] Add to __all__ list if exists
  - [ ] Verify import works: `python -c "from app.repositories import ApplicationRepository"`

- [ ] **Task 6: Update services __init__.py** (AC: 12)
  - [ ] Open `backend/app/services/__init__.py`
  - [ ] Import ApplicationService: `from app.services.application_service import ApplicationService`
  - [ ] Add to __all__ list if exists
  - [ ] Verify import works

- [ ] **Task 7: Code quality checks** (AC: 11, 13, 14)
  - [ ] Run linter: `cd backend && ruff check app/repositories/application_repository.py app/services/application_service.py`
  - [ ] Fix any linting issues
  - [ ] Run type checker (if mypy configured): `mypy app/repositories/application_repository.py app/services/application_service.py`
  - [ ] Verify all docstrings are complete
  - [ ] Verify all type hints are present

- [ ] **Task 8: Manual testing of repository methods** (AC: 1)
  - [ ] Create test script or use Python REPL
  - [ ] Test get_by_candidate_id with candidate who has applications
  - [ ] Test get_by_job_posting_id with job that has applications
  - [ ] Test check_existing_application returns None when no duplicate
  - [ ] Test check_existing_application returns existing when duplicate exists
  - [ ] Test update_status changes status correctly
  - [ ] Test link_interview sets interview_id and status
  - [ ] Verify eager loading works (relationships populated)

- [ ] **Task 9: Manual testing of service methods** (AC: 3, 4, 5, 6, 7, 8, 10)
  - [ ] Test create_application with valid job_posting_id
  - [ ] Verify application created with status='applied'
  - [ ] Verify interview created automatically with correct role_type
  - [ ] Verify application.interview_id set correctly
  - [ ] Verify application.status updated to 'interview_scheduled'
  - [ ] Test create_application with duplicate (should raise 409)
  - [ ] Test create_application with invalid job_posting_id (should raise 404)
  - [ ] Test create_application with inactive job (should raise 400)
  - [ ] Test transaction rollback: Mock interview_engine to fail, verify no application created
  - [ ] Test get_candidate_applications returns applications with relationships
  - [ ] Test get_application_by_id with valid ID and candidate_id
  - [ ] Test get_application_by_id with wrong candidate_id (should raise 403)

## Dev Notes

### Previous Story Insights
[From Story 3.1: Job Posting Data Models and Database Schema]

- **Models Created:** JobPosting and Application models successfully created with proper relationships
- **Application Model Location:** `backend/app/models/application.py`
- **Key Application Fields:**
  - candidate_id (FK to candidates, CASCADE delete)
  - job_posting_id (FK to job_postings, CASCADE delete)
  - interview_id (FK to interviews, SET NULL on delete) - nullable, set after interview creation
  - status enum: applied, interview_scheduled, interview_completed, under_review, rejected, offered, accepted, withdrawn
  - Unique constraint: (candidate_id, job_posting_id) prevents duplicates
- **Relationships Defined:**
  - Application -> Candidate (back_populates="applications")
  - Application -> JobPosting (back_populates="applications")
  - Application -> Interview (back_populates="applications")
- **Indexes Created:** candidate_id, job_posting_id, interview_id, status, applied_at

[From Story 3.2: Job Posting Repository and Service Layer]

- **JobPostingRepository Created:** Methods: get_by_id, get_all, get_active, filter_advanced
- **JobPostingService Created:** Business logic for retrieving and filtering job postings
- **Pattern Established:** Repository handles data access, Service handles business logic + validation
- **Location:** `backend/app/repositories/job_posting_repository.py`, `backend/app/services/job_posting_service.py`

### Repository Pattern
[Source: docs/architecture/coding-standards.md#repository-pattern, backend/app/repositories/base.py]

**BaseRepository Pattern:**
All repositories inherit from `BaseRepository[T]` abstract class providing common CRUD operations:

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Generic, TypeVar
from uuid import UUID

ModelType = TypeVar("ModelType")

class BaseRepository(Generic[ModelType]):
    """Abstract base repository for data access operations."""
    
    def __init__(self, db: AsyncSession, model: type[ModelType]):
        self.db = db
        self.model = model
    
    async def get_by_id(self, id: UUID) -> ModelType | None:
        """Retrieve a record by ID."""
        result = await self.db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()
    
    async def create(self, obj: ModelType) -> ModelType:
        """Create a new record."""
        self.db.add(obj)
        await self.db.flush()
        await self.db.refresh(obj)
        return obj
```

**Key Patterns:**
- Constructor takes `AsyncSession`, calls `super().__init__(db, Model)`
- Use `select()` from SQLAlchemy for queries
- Chain `.where()`, `.offset()`, `.limit()`, `.order_by()` for filtering/pagination
- Use `.execute()` to run query, then `.scalars().all()` or `.scalar_one_or_none()`
- Use `.flush()` instead of `.commit()` in repositories (transaction managed at service/API layer)

### Service Layer Pattern
[Source: docs/architecture/coding-standards.md#service-layer, backend/app/services/auth_service.py]

**Service Pattern:**
Services contain business logic, coordinate repositories, and handle errors:

```python
from app.repositories.application_repository import ApplicationRepository
from fastapi import HTTPException, status
import structlog
from uuid import UUID

logger = structlog.get_logger()

class ApplicationService:
    """Business logic for application operations."""
    
    def __init__(self, repo: ApplicationRepository):
        self.repo = repo
        self.logger = logger.bind(service="application_service")
    
    async def get_application_by_id(self, app_id: UUID) -> Application:
        """Get application by ID or raise 404."""
        self.logger.info("fetching_application", application_id=str(app_id))
        
        app = await self.repo.get_by_id(app_id)
        if not app:
            self.logger.warning("application_not_found", application_id=str(app_id))
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Application {app_id} not found"
            )
        
        return app
```

**Key Patterns:**
- Services receive repository instances via dependency injection
- Services use `structlog` for structured logging
- Services raise `HTTPException` with proper status codes (404, 400, 409, 500)
- Services validate input and apply business rules
- Services coordinate multiple repositories/services if needed
- Services return domain models or raise exceptions (no None returns for required data)

### Interview Integration Pattern
[Source: backend/app/services/interview_engine.py]

**InterviewEngine Service:**
The existing InterviewEngine service handles interview creation and management:

```python
class InterviewEngine:
    """Main interview orchestration service."""
    
    async def start_interview(
        self,
        candidate_id: UUID,
        role_type: str,
        use_realtime: bool = True
    ) -> InterviewSession:
        """
        Start a new interview session.
        
        Creates initial session with warmup difficulty level.
        
        Args:
            candidate_id: UUID of the candidate
            role_type: Type of role interview (e.g., "react", "python", "javascript", "fullstack")
            use_realtime: Whether to use Realtime API (default: True)
        
        Returns:
            Newly created InterviewSession with initialized state
        """
        # Creates InterviewSession record with proper initialization
        # Returns session that includes interview_id
```

**Integration Requirements:**
- ApplicationService receives InterviewEngine instance via dependency injection
- Call `interview_engine.start_interview(candidate_id, job_posting.role_type, use_realtime=True)`
- Returns `InterviewSession` which has `interview_id` field
- Extract `session.interview_id` to link to Application model
- If start_interview() raises exception, transaction will rollback automatically

### Transaction Management
[Source: backend/app/core/database.py]

**Transaction Pattern with FastAPI:**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db

# In API route
@router.post("/applications")
async def create_application(
    data: ApplicationCreateRequest,
    db: AsyncSession = Depends(get_db),
    current_candidate: Candidate = Depends(get_current_candidate)
):
    # Transaction begins when session is obtained
    service = ApplicationService(app_repo, job_repo, interview_engine)
    application = await service.create_application(...)
    
    # Transaction commits when endpoint returns successfully
    # Transaction rolls back if exception is raised
    return application
```

**Key Points:**
- `get_db()` dependency manages transaction lifecycle
- Transaction begins when session is created
- Transaction commits when endpoint returns successfully
- Transaction rolls back automatically if exception is raised
- Services should NOT call `db.commit()` or `db.rollback()` - handled by FastAPI
- Use `await db.flush()` in repositories to persist changes within transaction
- Use `await db.refresh(obj)` to reload object after flush

**Atomicity for Application + Interview:**
The create_application flow must be atomic:
1. Create application record (flush)
2. Create interview via InterviewEngine (flush)
3. Link interview_id to application (flush)
4. If any step fails, entire transaction rolls back
5. No partial state (application without interview)

### Eager Loading Relationships
[Source: SQLAlchemy 2.0 documentation]

**Problem:** N+1 queries when accessing relationships
```python
# Without eager loading - causes N+1 queries
applications = await repo.get_by_candidate_id(candidate_id)
for app in applications:
    print(app.job_posting.title)  # Separate query for each!
```

**Solution:** Use selectinload or joinedload
```python
from sqlalchemy.orm import selectinload

# With eager loading - single query
stmt = (
    select(Application)
    .options(
        selectinload(Application.job_posting),
        selectinload(Application.interview)
    )
    .where(Application.candidate_id == candidate_id)
    .order_by(Application.applied_at.desc())
    .offset(skip)
    .limit(limit)
)
result = await self.db.execute(stmt)
applications = result.scalars().all()

# Now relationships are pre-loaded
for app in applications:
    print(app.job_posting.title)  # No additional query!
```

**When to Use:**
- Use `selectinload` for one-to-many relationships (default choice)
- Use `joinedload` for many-to-one relationships when you always need the related object
- Always eager load relationships that will be accessed in API responses

### Error Handling
[Source: docs/architecture/coding-standards.md#fastapi-routes]

**HTTP Status Codes:**
- 200 OK - Successful GET, PUT, PATCH
- 201 Created - Successful POST
- 400 Bad Request - Invalid input/validation error (e.g., job posting not active)
- 401 Unauthorized - Missing/invalid authentication
- 403 Forbidden - Authenticated but not authorized (e.g., wrong candidate_id)
- 404 Not Found - Resource doesn't exist (e.g., job_posting_id invalid)
- 409 Conflict - Duplicate resource (e.g., already applied)
- 422 Unprocessable Entity - Pydantic validation failed
- 500 Internal Server Error - Unexpected server error

**HTTPException Pattern:**
```python
from fastapi import HTTPException, status

# Not found
if not resource:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Resource not found"
    )

# Duplicate/conflict
if existing:
    raise HTTPException(
        status_code=status.HTTP_409_CONFLICT,
        detail="Already applied to this job"
    )

# Forbidden (authorization)
if application.candidate_id != current_candidate_id:
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="Not authorized to access this application"
    )
```

### Type Hints and Docstrings
[Source: docs/architecture/coding-standards.md#type-hints]

**Required Type Hints:**
- All function parameters must have type hints
- All function return types must be specified
- Use `Optional[T]` or `T | None` for nullable values
- Use `list[T]`, `dict[K, V]` (Python 3.9+ syntax)
- Use `tuple[T1, T2]` for fixed-size tuples

**Docstring Pattern (Google Style):**
```python
async def create_application(
    self,
    candidate_id: UUID,
    job_posting_id: UUID
) -> tuple[Application, InterviewSession]:
    """
    Create a new application and automatically start interview.
    
    Creates application record, validates job posting is active,
    checks for duplicates, then automatically creates and links
    interview session. All operations are atomic within a transaction.
    
    Args:
        candidate_id: UUID of the candidate applying
        job_posting_id: UUID of the job posting to apply to
    
    Returns:
        Tuple of (Application, InterviewSession) both fully populated
    
    Raises:
        HTTPException 404: If job posting not found
        HTTPException 400: If job posting is not active
        HTTPException 409: If candidate already applied to this job
        HTTPException 500: If interview creation fails
    """
    # Implementation
```

### File Locations
[Source: docs/architecture/backend/09-source-tree-structure.md]

**Files to Create:**
- `backend/app/repositories/application_repository.py` - Application data access
- `backend/app/services/application_service.py` - Application business logic + interview triggering

**Files to Update:**
- `backend/app/repositories/__init__.py` - Add ApplicationRepository import
- `backend/app/services/__init__.py` - Add ApplicationService import

**Reference Files:**
- `backend/app/repositories/base.py` - BaseRepository implementation
- `backend/app/repositories/candidate.py` - Example repository
- `backend/app/repositories/job_posting_repository.py` - Story 3.2 repository
- `backend/app/services/auth_service.py` - Example service
- `backend/app/services/job_posting_service.py` - Story 3.2 service
- `backend/app/services/interview_engine.py` - InterviewEngine service to integrate with
- `backend/app/models/application.py` - Application model (Story 3.1)
- `backend/app/models/job_posting.py` - JobPosting model (Story 3.1)

### Technical Constraints

**Async/Await Pattern:**
[Source: docs/architecture/backend/02-high-level-architecture.md]
- All repository methods must be async (`async def`)
- All database operations must use `await`
- Use `AsyncSession` from sqlalchemy.ext.asyncio
- No blocking I/O operations in async functions

**SQLAlchemy 2.0 Patterns:**
- Use `select()` for queries (not `Query` API)
- Use `.execute()` to run statements
- Use `.scalars()` for ORM objects, `.all()` to collect
- Use `.scalar_one_or_none()` for single results
- Use functional style with method chaining
- Use `selectinload()` for eager loading relationships

**Logging Pattern:**
[Source: docs/architecture/backend/11-error-handling-logging.md]
- Use `structlog` for structured logging
- Bind service name in constructor: `logger.bind(service="service_name")`
- Log at appropriate levels: info, warning, error
- Include relevant context: IDs, operation names, error details

**Dependency Injection Pattern:**
[Source: backend/app/api/v1/*.py]
- Services receive dependencies via constructor
- Repositories instantiated with database session
- Pattern used in API routes:
```python
def get_application_service(
    db: AsyncSession = Depends(get_db)
) -> ApplicationService:
    app_repo = ApplicationRepository(db)
    job_repo = JobPostingRepository(db)
    # Interview engine would be injected via another dependency
    interview_engine = get_interview_engine(db)
    return ApplicationService(app_repo, job_repo, interview_engine)
```

## Testing

### Manual Testing Strategy
[Source: docs/architecture/backend/13-test-strategy.md]

This story focuses on repository and service layer implementation without API endpoints. Testing will be manual using Python REPL or test scripts.

**Test Environment Setup:**
1. Ensure database migration from Story 3.1 is applied
2. Ensure database has sample job postings (from Story 3.2 seed data)
3. Ensure at least one candidate exists for testing
4. Use Python REPL or create temporary test script

**Test Pattern:**
```python
# In Python REPL or test script
import asyncio
from uuid import uuid4, UUID
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import AsyncSessionLocal
from app.repositories.application_repository import ApplicationRepository
from app.repositories.job_posting_repository import JobPostingRepository
from app.services.application_service import ApplicationService
from app.services.interview_engine import InterviewEngine

async def test_application_service():
    async with AsyncSessionLocal() as session:
        # Setup repositories
        app_repo = ApplicationRepository(session)
        job_repo = JobPostingRepository(session)
        
        # Get test data
        jobs = await job_repo.get_active(skip=0, limit=1)
        test_job = jobs[0]
        test_candidate_id = UUID("...")  # Use real candidate ID
        
        # Test application creation
        service = ApplicationService(app_repo, job_repo, interview_engine)
        application, interview = await service.create_application(
            test_candidate_id,
            test_job.id
        )
        
        print(f"Application created: {application.id}")
        print(f"Interview created: {interview.interview_id}")
        print(f"Application status: {application.status}")
        print(f"Interview linked: {application.interview_id}")
        
        # Commit transaction
        await session.commit()

# Run test
asyncio.run(test_application_service())
```

**Test Checklist:**
- [ ] Repository methods return correct data types
- [ ] Pagination works (skip/limit respected)
- [ ] Eager loading loads relationships (no N+1 queries)
- [ ] Duplicate check works (returns existing application)
- [ ] Service creates application successfully
- [ ] Service creates interview automatically
- [ ] Interview has correct role_type from job posting
- [ ] Application.interview_id set correctly
- [ ] Application.status updated to 'interview_scheduled'
- [ ] Service raises HTTPException 404 for invalid job_posting_id
- [ ] Service raises HTTPException 409 for duplicate application
- [ ] Service raises HTTPException 400 for inactive job posting
- [ ] Transaction rollback works (mock interview_engine to fail)

**Note:** Automated unit tests can be added later following patterns in `backend/tests/unit/test_auth_service.py` if needed.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-04 | 1.0 | Initial story draft created | SM Agent (Bob) |

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (2024-10-22)

### Debug Log References
None

### Completion Notes
- Successfully implemented ApplicationRepository with all required methods including eager loading via selectinload
- Successfully implemented ApplicationService with full business logic for application creation, interview triggering, and authorization
- **Key Implementation Detail:** JobPosting model uses `tech_stack` field (not `role_type`), which is mapped to Interview.role_type enum values
- **Interview Creation Flow:** Service creates Interview record first, then creates InterviewSession linked to it (InterviewEngine.start_interview was using candidate_id as placeholder)
- All HTTP status codes properly implemented (404, 400, 409, 403)
- Transaction handling follows FastAPI patterns - automatic rollback on exception
- Structured logging added for all operations
- Code passes all linter checks (ruff)
- Manual testing confirmed all functionality works correctly
- File created: `backend/test_application_manual.py` for testing (can be removed or kept for future reference)

### File List
**New Files:**
- `backend/app/repositories/application_repository.py`
- `backend/app/services/application_service.py`

**Modified Files:**
- `backend/app/repositories/__init__.py`
- `backend/app/services/__init__.py`

---

**Epic:** Epic 03: Job-Driven AI Interview Flow  
**Dependencies:** Story 3.1 (Application model), Story 3.2 (JobPostingRepository)  
**Blocks:** Story 3.5 (Application REST API Endpoints)
